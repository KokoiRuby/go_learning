## [Btree](https://github.com/wardseptember/notes/blob/master/docs/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E8%AF%A6%E8%A7%A3.md#b%E6%A0%91)

**背景**：

Btree 的出现是为了弥合不同的存储级别之间的访问速度上的巨大差异，实现高效 I/O。

平衡二叉树的查找效率是非常高的，并可以通过降低树的深度来提高查找的效率。

但数据量增大时，还是不可避免会 ∵ 深度++ 导致 I/O 效率下降 :cry:

**What?**

Btree 是一种**自平衡**的树，是 BST 的一般化。适合读写相对较大的数据块，**常用于 DB & FS**。

对于 m 阶数 (order) 的 Btree，**m 为一个子节点的最大个数**。

- 每个节点最多只有 m 个子节点。
- 每个非叶子节点（除了根）具有至少 m/2 子节点。
- 如果根不是叶节点，则根至少有 2 个子节点。
- 具有 k 个子节点的非叶节点包含 k-1 个键。
- 所有叶子都出现在同一水平，没有任何信息（高度一致）。

![image-20240712131747362](./btree_b+tree.assets/image-20240712131747362.png)

:bookmark_tabs: 一旦确定阶数 m，即可确定：

**Root 根节点** (10): 子节点数量：`2 <= M <= m`，元素数量：`1 <= K = m-1`

**Internal 内部节点** (3/6): 子节点数量：`m/2 <= M <= m`，元素数量：`m/2-1 <= K = m-1`

**Leaf 叶节点** (1/2)：元素数量：`m/2-1 <= K = m-1`。

### Insert

判断 Btree 中是否存在，不存在则在叶节点尾插入。

- 若该节点元素个数小于 m-1，直接插入；
- 若该节点元素个数等于 m-1，引起**节点分裂**；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中；
- 重复上面动作，**直到所有节点符合 Btree 的约束**；最坏的情况一直分裂到根节点，生成新的根节点，高度增加 1；

### Remove

判断 Btree 中是否存在，则将该元素在其结点中进行删除（依次向前移动）。

删除该元素后，首先判断该元素**是否有左右子结点**；如果有，则**上移子结点中的某相近元素（左子节点最右，右子节点最左）到父节点**中；如果没有，则直接删除。

- 某结点中元素数目小于 `m/2-1` 向上取整，则需要看其某**相邻结点是否丰满**；
- 如果丰满（结点中元素个数大于 `m/2-1`），则向父节点借一个元素来满足条件；
- 如果其相邻兄弟都不丰满，即其结点数目等于 `m/2-1`，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点；

### Disk IO

**vs**

内存：SRAM (1~10ns) vs. DRAM (10~100ns)

磁盘：SSD (100~500μs) vs. HDD (10~20ms)

**优化**

每次 IO 按 page 页 (4/8k) 磁盘加载到内存，尽可能多读取一些。

**事实**

1. 为避免一次磁盘访问，宁愿多访问几次内存，将常用数据保存在尽可能快的读取设备中。
2. 索引查询受限于磁盘 IO，所以 IO 次数越少越好，才有了 Btree。
   - 每个节点的元素可以视为一次 IO 读取，树的高度表示最多的 IO 次数
   - 每个节点的元素越多，高度越低，IO 次数越少

E.g. 假设每次 I/O 可以读取 8K 数据，而**索引**使用 int 类型数据 4byte，每个节点可保存 2000 个元素。每层元素数：2000<sup>n</sup>，第 3 层可以有 80 亿个元素。只需要 3 次 IO 即可完成。

### Height

$h \leq \log_{\lceil m/2 \rceil} \left(N(\lceil m/2 \rceil - 1) + 1\right)$

## B+tree

**背景：**

我们希望通过索引提高擦汗寻效率；存储上不占用太多空间。支持快速查询/插入的动态数据结构：

- 哈希表：O(1) 查询，但不支持范围查询。
- 平衡二叉查找树/红黑树：O(logn) 查询，中序遍历可得有序序列，但不支持范围查询。
- 跳表：O(logn) 查询，多级索引，支持范围查询。

**改造 BST：**

树中的节点并不存储数据本身，而是只是作为索引。

每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。

![image-20240712144234428](./btree_b+tree.assets/image-20240712144234428.png)

**范围查询：**区间起始，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。

![image-20240712144436619](./btree_b+tree.assets/image-20240712144436619.png)

**索引：**如何为几千万、上亿的数据构建索引？

将索引保存在磁盘中，而不是内存 (假如每个索引占 16 byte，1 亿个数据，就接近 1GB)

但在数据查找的过程中，从磁盘中读取索引效率就会降低很多。∴ 要尽可能减少磁盘 IO，而树的高度就对应了磁盘 IO 的次数。将二叉树 → m 阶叉树，可降低树的高度。

![image-20240712145840888](./btree_b+tree.assets/image-20240712145840888.png)

![image-20240712145301278](./btree_b+tree.assets/image-20240712145301278.png)

**m 越大越好？**

内存/磁盘都是按页读取 (4/8K)，如果超过，就会触发多次 IO，应保持每个节点大小 < page size。

![image-20240712145957353](./btree_b+tree.assets/image-20240712145957353.png)

**索引利弊**：提高查询速度，但会降低写入效率，∵ 涉及索引的更新。

写入过程**可能会导致原本 B+tree 的约束被破坏**，需要调整进行调整以满足约束，这就有了额外的开销。