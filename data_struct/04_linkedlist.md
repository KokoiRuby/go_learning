链表**非连续内存**，通过**指针**将零散的内存块**串联**起来，内存块表示为节点 node。

**单链表**：head(base_addr), tail(→ nil)

- :smile: 插入/删除：O(1) 只需要改变相邻结点的指针指向。
- :cry: 查询：O(n) 只能一个接着一个找。



![image-20240703214830994](04_linkedlist.assets/image-20240703214830994.png)



![image-20240703215032735](04_linkedlist.assets/image-20240703215032735.png)



**循环链表**：tail(→ head) 解决[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)



![image-20240703215548676](04_linkedlist.assets/image-20240703215548676.png)



**双向链表**：prev + next (→ prev of nxt node) 额外空间保存指针信息 → 典型：空间换时间。

- 删除：需要知道前一个节点的地址，修改指向要删除节点的下一个节点。
  - <u>给定值</u>的节点：单纯操作 O(1)，但遍历要 O(n)
  - <u>给定指针</u>的节点：节点自带 prev，O(1)
- 插入：同理，节点自带 prev，修改前一个节点指向自身，将自身指向下一个节点，同时像一个节点回指。O(1)



![image-20240703215636614](04_linkedlist.assets/image-20240703215636614.png)



![image-20240703220434187](04_linkedlist.assets/image-20240703220434187.png)



**缓存**是一种提高数据读取性能的技术，常见于 CPU/DB/Browser。

缓存策略：FIFO, LFU 最少使用, **LRU 最近最少使用**

实现：单链表即可

1. 如果数据存在链表中，遍历获取节点，将其插入到 head。
2. 如果数据没有在其中
   - 缓存未满：直接插入到 head
   - 缓存已满：删除 tail，插入到 head。



#### :construction_worker: **Practice**

1. **理解指针/引用的含义**：指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量（的值）。

```go
// p 节点中的 next 指针存储了 q 节点的内存地址
p->next=q

// p 节点的 next 指针存储了 p 节点的下下一个结点的内存地址
p->next=p->next->next
```

2. **留意指针丢失和内存泄漏**：注意操作顺序，先将插入节点的指针指向下一个节点，再将上一个节点指向插入节点。

```go
// a → b
// ↓
// a → x → b
x->next = b
a->next = x
```

3. **哨兵节点降低难度**：针对插入/删除，需要对头尾节点做特殊处理。

   带头链表：++哨兵节点，不管链表是否为空，head 指针都指向它，不存储数据。

![image-20240705091422830](04_linkedlist.assets/image-20240705091422830.png)

4. **留意边界问题**
   - 如果链表为空时，代码是否能正常工作？
   - 如果链表只包含一个结点时，代码是否能正常工作？
   - 如果链表只包含两个结点时，代码是否能正常工作？
   - 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
5. **举例画图，辅助思考**
6. **多写多练**
   - **单链表反转**：
   
     - 需要 3 个指针 pre/cur/next 从 head 开始遍历
   
     - next 保存当前节点下一个节点
   
     - 当前节点下一个指向上一个节点
   
     - pre/cur 同时向前步进
   
     - 最后，将 head 下一个节点指向 pre (遍历到的最后一个节点)
   
       
   
   - **链表中环的检测**：快慢指针法，如果存在环，那么它们必将相遇。
   
     - slow/fast 分别以不同的速率从 head 开始遍历
   
     - 如果存在环，那么必然相遇 slow == fast
   
       
   
   - **两个<u>有序</u>的链表合并**
   
     - 先分别做非空判断
   
     - 新建一个链表，设置 3 个初始指针分别指向 3 链表开头
   
       - 新链表 head
       - 剩余 2 个 head.next
   
     - 循环遍历，只要 2 个链表的节点都不为空，就进行比较（Go 要进行类型断言，将接口类型转换成目标类型）。
   
       - 新链表 head.next 指向其中较小/较大的（升序/降序），并同时步进指针。
   
     - 最后若长度不相等，将新链表指向还未遍历完毕的链表即可。
   
       
   
   - **删除链表倒数第 N 个结点**
   
     - 双指针，先移动 N，然后同时向前移动，直到尾部，那么后一个指针指向的就是倒数第 N 个前一个节点。
     - 只要将 slow → slow.next.next 同时置 slow 为 nil 即可。
   
   
   
   - **求链表的中间结点**：快慢指针法
     - fast 以两倍速度先遍历完，最终返回 slow。

