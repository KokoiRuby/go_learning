链表**非连续内存**，通过**指针**将零散的内存块**串联**起来，内存块表示为节点 node。

**单链表**：head(base_addr), tail(→ nil)

- :smile: 插入/删除：O(1) 只需要改变相邻结点的指针指向。
- :cry: 查询：O(n) 只能一个接着一个找。



![image-20240703214830994](04_linkedlist.assets/image-20240703214830994.png)



![image-20240703215032735](04_linkedlist.assets/image-20240703215032735.png)



**循环链表**：tail(→ head) 解决[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)



![image-20240703215548676](04_linkedlist.assets/image-20240703215548676.png)



**双向链表**：prev + next (→ prev of nxt node) 额外空间保存指针信息 → 典型：空间换时间。

- 删除：需要知道前一个节点的地址，修改指向要删除节点的下一个节点。
  - <u>给定值</u>的节点：单纯操作 O(1)，但遍历要 O(n)
  - <u>给定指针</u>的节点：节点自带 prev，O(1)
- 插入：同理，节点自带 prev，修改前一个节点指向自身，将自身指向下一个节点，同时像一个节点回指。O(1)



![image-20240703215636614](04_linkedlist.assets/image-20240703215636614.png)



![image-20240703220434187](04_linkedlist.assets/image-20240703220434187.png)



**缓存**是一种提高数据读取性能的技术，常见于 CPU/DB/Browser。

缓存策略：FIFO, LFU 最少使用, **LRU 最近最少使用**

实现：单链表即可

1. 如果数据存在链表中，遍历获取节点，将其插入到 head。
2. 如果数据没有在其中
   - 缓存未满：直接插入到 head
   - 缓存已满：删除 tail，插入到 head。



#### :construction_worker: **Practice**

1. **理解指针/引用的含义**：指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量（的值）。

```go
// p 节点中的 next 指针存储了 q 节点的内存地址
p->next=q

// p 节点的 next 指针存储了 p 节点的下下一个结点的内存地址
p->next=p->next->next
```

2. **留意指针丢失和内存泄漏**：注意操作顺序，先将插入节点的指针指向下一个节点，再将上一个节点指向插入节点。

```go
// a → b
// ↓
// a → x → b
x->next = b
a->next = x
```

3. **哨兵节点降低难度**：针对插入/删除，需要对头尾节点做特殊处理。

   带头链表：++哨兵节点，不管链表是否为空，head 指针都指向它，不存储数据。

![image-20240705091422830](04_linkedlist.assets/image-20240705091422830.png)

4. **留意边界问题**
   - 如果链表为空时，代码是否能正常工作？
   - 如果链表只包含一个结点时，代码是否能正常工作？
   - 如果链表只包含两个结点时，代码是否能正常工作？
   - 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
5. **举例画图，辅助思考**
6. **多写多练**
   - 单链表反转
   - 链表中环的检测
   - 两个有序的链表合并
   - 删除链表倒数第 n 个结点
   - 求链表的中间结点

